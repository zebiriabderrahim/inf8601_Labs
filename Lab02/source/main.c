/* DO NOT EDIT THIS FILE */

#include <limits.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WITH_VIEWER
#include <GL/glut.h>
#endif

#include "headless.h"
#include "log.h"
#include "opencl.h"
#include "sinoscope.h"
#include "viewer.h"

__attribute__((weak))
char* opencl_kernel_path;

__attribute__((weak))
int sinoscope_image_openmp(sinoscope_t* sinoscope) {
	return -1;
}

__attribute__((weak)) int viewer_init(sinoscope_t* sinoscope) {
    return 0;
}

__attribute__((weak)) int viewer_open() {
    return 0;
}

__attribute__((weak)) void viewer_destroy() {

}

__attribute__((weak))
int sinoscope_opencl_init(sinoscope_opencl_t* opencl, cl_device_id opencl_device_id, unsigned int width,
			  unsigned int height) {
	return 0;
}

__attribute__((weak))
void sinoscope_opencl_cleanup(sinoscope_opencl_t* opencl)
{

}

__attribute__((weak))
int sinoscope_image_opencl(sinoscope_t* sinoscope) {
	return 0;
}

__attribute__((weak))
int opencl_load_kernel_code(char** code, size_t* len)
{
	return 0;
}

__attribute__((weak))
int opencl_get_device_id(unsigned int platform_index, unsigned int device_index, cl_device_id* context_device_id)
{
	return 0;
}

__attribute__((weak))
int opencl_print_device_info(cl_device_id device_id)
{
	return 0;
}

__attribute__((weak))
int opencl_print_build_log(cl_program program, cl_device_id device_id)
{
	return 0;
}

static void show_help(FILE* f, const char* exec_name) {
    fprintf(f, "Usage: %s [OPTION]...\n", exec_name);
    fprintf(f, "\n");
    fprintf(f, "Options:\n");
    fprintf(f,
            "  --method [serial|openmp|opencl] computation method to use "
            "(default: serial)\n");
    fprintf(f,
            "  --width N                       width of the simulation "
            "(default: 512)\n");
    fprintf(f,
            "  --height N                      height of the simulation "
            "(default: 512)\n");
    fprintf(f,
            "  --taylor N                      degree of the taylor "
            "polynomial (default: 6)\n");
    fprintf(f,
            "  --opencl-platform N             opencl platform index to use "
            "(default: 0)\n");
    fprintf(f,
            "  --opencl-device N               opencl device index to use "
            "(default: 0)\n");
    fprintf(f,
            "  --opencl-kernel FILE            use a custom opencl kernel "
            "location\n");
    fprintf(f,
            "  --headless                      run the computation without "
            "graphical interface\n");
    fprintf(f, "  --save FILE                     save a frame into a PNG image\n");
    fprintf(f, "  --benchmarks N                  benchmark all implementations for N iterations\n");
    fprintf(f, "  --benchmark VARIANT N           benchmark VARIANT for N iterations\n");
    fprintf(f, "  --check VARIANT                 check VARIANT outputs\n");
    fprintf(f, "  --help                          show this help\n");
}

static void fail_missing_argument(const char* exec_name, const char* opt) {
    fprintf(stderr, "%s: option '%s' requires an argument\n", exec_name, opt);
    fprintf(stderr, "Try '%s --help' for more information.\n", exec_name);
    exit(1);
}

static void fail_unknown_argument(const char* exec_name, const char* opt) {
    fprintf(stderr, "%s: unrecognized option '%s'\n", exec_name, opt);
    fprintf(stderr, "Try '%s --help' for more information.\n", exec_name);
    exit(1);
}

static void fail_unknown_method(const char* exec_name, const char* arg) {
    fprintf(stderr, "%s: unrecognized argument '%s' for option `--method`\n", exec_name, arg);
    fprintf(stderr, "Try '%s --help' for more information.\n", exec_name);
    exit(1);
}

static void fail_multiple_method(const char* exec_name) {
    fprintf(stderr, "%s: zero or one option `--method` must be specified\n", exec_name);
    fprintf(stderr, "Try '%s --help' for more information.\n", exec_name);
    exit(1);
}

static void fail_argument_parsing(const char* exec_name, const char* arg_name, const char* arg) {
    fprintf(stderr, "%s: failed to parse '%s' for argument `%s`\n", exec_name, arg, arg_name);
    fprintf(stderr, "Try '%s --help' for more information.\n", exec_name);
    exit(1);
}

static void fail_argument_require_positive(const char* exec_name, const char* arg_name) {
    fprintf(stderr, "%s: argument `%s` requires a positive number\n", exec_name, arg_name);
    fprintf(stderr, "Try '%s --help' for more information.\n", exec_name);
    exit(1);
}

static unsigned int get_strictly_positive_integer_or_fail(const char* exec_name, const char* arg_name,
                                                          const char* arg) {
    long int value = strtol(arg, NULL, 10);
    if (value == LONG_MIN || value == LONG_MAX) {
        fail_argument_parsing(exec_name, arg_name, arg);
    }

    if (value <= 0) {
        fail_argument_require_positive(exec_name, arg_name);
    }

    return value;
}

static unsigned int get_positive_integer_or_fail(const char* exec_name, const char* arg_name, const char* arg) {
    long int value = strtol(arg, NULL, 10);
    if (value == LONG_MIN || value == LONG_MAX) {
        fail_argument_parsing(exec_name, arg_name, arg);
    }

    if (value < 0) {
        fail_argument_require_positive(exec_name, arg_name);
    }

    return value;
}

static void run_headless(sinoscope_t* sinoscope) {
    if (headless_run(sinoscope) < 0) {
        LOG_ERROR("failed to run headless");
        exit(1);
    }
}

static void run_benchmark_serial(unsigned int width, unsigned int height, unsigned int taylor,
				 float max, unsigned int iterations) {

	sinoscope_t *s = sinoscope_create("serial", sinoscope_image_serial, width, height, max);

	if (!s) {
		LOG_ERROR("failed to create sinoscope (serial)");
		exit(1);
	}
	s->taylor = taylor;
	if (sinoscope_benchmark(s, iterations) < 0) {
        LOG_ERROR("failed to check ouputs");
        exit(1);
    }
}

static void run_benchmark_mp(unsigned int width, unsigned int height, unsigned int taylor,
			     float max, unsigned int iterations) {

		sinoscope_t *s = sinoscope_create("openmp", sinoscope_image_openmp, width, height, max);

	if (!s) {
		LOG_ERROR("failed to create sinoscope (openmp)");
		exit(1);
	}

	s->taylor = taylor;

	if (sinoscope_benchmark(s, iterations) < 0) {
        LOG_ERROR("failed to check ouputs");
        exit(1);
    }
}

static void run_benchmark_cl(sinoscope_opencl_t* opencl, unsigned int width, unsigned int height, unsigned int taylor,
			     float max, unsigned int iterations) {
	sinoscope_t *s = sinoscope_create("opencl", sinoscope_image_opencl, width, height, max);

	if (!s) {
		LOG_ERROR("failed to create sinoscope (serial)");
		exit(1);
	}
	s->taylor = taylor;
	s->opencl = opencl;
	if (sinoscope_benchmark(s, iterations) < 0) {
        LOG_ERROR("failed to check ouputs");
        exit(1);
    }
}

static void run_benchmarks(sinoscope_opencl_t* opencl, unsigned int width, unsigned int height, unsigned int taylor,
                          float max, unsigned int iterations) {
    if (sinoscope_benchmarks(width, height, taylor, max, opencl, iterations) < 0) {
        LOG_ERROR("failed to check ouputs");
        exit(1);
    }
}

static void run_check_mp(unsigned int width, unsigned int height, unsigned int taylor,
			 float max) {
    if (sinoscope_check(width, height, taylor, max, NULL) < 0) {
        LOG_ERROR("failed to check ouputs");
        exit(1);
    }
}


static void run_check_cl(sinoscope_opencl_t* opencl, unsigned int width, unsigned int height, unsigned int taylor,
			 float max) {
    if (sinoscope_check(width, height, taylor, max, opencl) < 0) {
        LOG_ERROR("failed to check ouputs");
        exit(1);
    }
}

static void run_viewer(sinoscope_t* sinoscope) {
    if (viewer_init(sinoscope) < 0) {
        LOG_ERROR("failed to initialise viewer");
        exit(1);
    }

    if (viewer_open() < 0) {
        LOG_ERROR("failed to open viewer");
        exit(1);
    }

    viewer_destroy();
}

static sinoscope_opencl_t* configure_opencl(unsigned int platform, unsigned int device, sinoscope_opencl_t* opencl,
                                            unsigned int width, unsigned int height) {
    cl_device_id device_id;
    if (opencl_get_device_id(platform, device, &device_id) < 0) {
        LOG_ERROR("failed to get device ID");
        goto fail_exit;
    }

    if (opencl_print_device_info(device_id) < 0) {
        LOG_ERROR("failed to print opencl device information");
        goto fail_exit;
    }

    if (sinoscope_opencl_init(opencl, device_id, width, height) < 0) {
        LOG_ERROR("failed to initialize OpenCL context");
        goto fail_exit;
    }

    return opencl;

fail_exit:
    printf("Disabling OpenCL support\n");
    return NULL;
}

int main(int argc, char* argv[]) {
#ifdef WITH_VIEWER
    if (getenv("DISPLAY") != NULL) {
        glutInit(&argc, argv);
    }
#endif

    char* exec_name        = argv[0];
    bool use_method_serial = false;
    bool use_method_openmp = false;
    bool use_method_opencl = false;
    int use_method_count   = 0;
    bool do_run_headless   = false;
    bool do_benchmarks      = false;
    bool do_save_image     = false;
    char *check            = NULL;
    char *benchmark        = NULL;

    char* save_filename = NULL;

    unsigned int width      = 512;
    unsigned int height     = 512;
    unsigned int taylor     = 6;
    unsigned int iterations = 0;

    unsigned int opencl_platform_index = 0;
    unsigned int opencl_device_index   = 0;

    for (int i = 1; i < argc; i++) {
        if (strcmp("--method", argv[i]) == 0) {
            if (i >= argc - 1) {
                fail_missing_argument(exec_name, argv[i]);
            }

            if (strcmp("serial", argv[i + 1]) == 0) {
                use_method_serial = true;
                use_method_count++;
            } else if (strcmp("openmp", argv[i + 1]) == 0) {
                use_method_openmp = true;
                use_method_count++;
            } else if (strcmp("opencl", argv[i + 1]) == 0) {
                use_method_opencl = true;
                use_method_count++;
            } else {
                fail_unknown_method(exec_name, argv[i + 1]);
            }

            i++;
        } else if (strcmp("--width", argv[i]) == 0) {
            if (i >= argc - 1) {
                fail_missing_argument(exec_name, argv[i]);
            }

            width = get_strictly_positive_integer_or_fail(exec_name, argv[i], argv[i + 1]);
            i++;
        } else if (strcmp("--height", argv[i]) == 0) {
            if (i >= argc - 1) {
                fail_missing_argument(exec_name, argv[i]);
            }

            height = get_strictly_positive_integer_or_fail(exec_name, argv[i], argv[i + 1]);
            i++;
        } else if (strcmp("--taylor", argv[i]) == 0) {
            if (i >= argc - 1) {
                fail_missing_argument(exec_name, argv[i]);
            }

            taylor = get_strictly_positive_integer_or_fail(exec_name, argv[i], argv[i + 1]);
            i++;
        } else if (strcmp("--opencl-platform", argv[i]) == 0) {
            if (i >= argc - 1) {
                fail_missing_argument(exec_name, argv[i]);
            }

            opencl_platform_index = get_positive_integer_or_fail(exec_name, argv[i], argv[i + 1]);
            i++;
        } else if (strcmp("--opencl-device", argv[i]) == 0) {
            if (i >= argc - 1) {
                fail_missing_argument(exec_name, argv[i]);
            }

            opencl_device_index = get_positive_integer_or_fail(exec_name, argv[i], argv[i + 1]);
            i++;
        } else if (strcmp("--opencl-kernel", argv[i]) == 0) {
            if (i >= argc - 1) {
                fail_missing_argument(exec_name, argv[i]);
            }

            opencl_kernel_path = argv[i + 1];
            i++;
        } else if (strcmp("--headless", argv[i]) == 0) {
            do_run_headless = true;
        } else if (strcmp("--save", argv[i]) == 0) {
            if (i >= argc - 1) {
                fail_missing_argument(exec_name, argv[i]);
            }

            do_save_image = true;
            save_filename = argv[i + 1];
            i++;
        } else if (strcmp("--benchmarks", argv[i]) == 0) {
            if (i >= argc - 1) {
                fail_missing_argument(exec_name, argv[i]);
            }

            iterations = get_strictly_positive_integer_or_fail(exec_name, argv[i], argv[i + 1]);
            i++;

            do_benchmarks = true;

	} else if (strcmp("--benchmark", argv[i]) == 0) {
            if (i >= argc - 2) {
                fail_missing_argument(exec_name, argv[i]);
            }

	    benchmark = argv[++i];

            iterations = get_strictly_positive_integer_or_fail(exec_name, argv[i], argv[i + 1]);
            i++;

        } else if (strcmp("--check", argv[i]) == 0) {
		if (i >= argc - 1) {
			fail_missing_argument(exec_name, argv[i]);
		}
		check = argv[i + 1];
		i++;
        } else if (strcmp("--help", argv[i]) == 0) {
            show_help(stdout, exec_name);
            exit(0);
        } else {
            fail_unknown_argument(exec_name, argv[i]);
        }
    }

    sinoscope_t* sinoscope = NULL;
    sinoscope_opencl_t sinoscope_opencl;
    sinoscope_opencl_t* sinoscope_opencl_ptr = NULL;

    if (do_benchmarks) {
	    sinoscope_opencl_ptr =
        configure_opencl(opencl_platform_index, opencl_device_index, &sinoscope_opencl, width, height);

        run_benchmarks(sinoscope_opencl_ptr, width, height, taylor, 200.0, iterations);
        goto done;
    }

    if (benchmark)  {

	    if (0 == strcmp(benchmark, "serial")) {
		    run_benchmark_serial(width, height, taylor, 200.0, iterations);
	    } else if (0 == strcmp(benchmark, "mp")) {
		    run_benchmark_mp(width, height, taylor, 200.0, iterations);
	    } else if(0 == strcmp(benchmark, "cl")) {
		    	    sinoscope_opencl_ptr =
		    configure_opencl(opencl_platform_index, opencl_device_index, &sinoscope_opencl, width, height);

			    run_benchmark_cl(sinoscope_opencl_ptr, width, height, taylor, 200.0, iterations);
	    } else {
		    fprintf(stderr, "Invalid benchmark: %s\n", check);
		    exit(EXIT_FAILURE);
	    }

	    goto done;
    }

    if (check) {

	    if (0 == strcmp(check, "mp")) {
		    run_check_mp(width, height, taylor, 200.0);
	    } else if(0 == strcmp(check, "cl")) {
		    	    sinoscope_opencl_ptr =
		    configure_opencl(opencl_platform_index, opencl_device_index, &sinoscope_opencl, width, height);

		    run_check_cl(sinoscope_opencl_ptr, width, height, taylor, 200.0);
	    } else {
		    fprintf(stderr, "Invalid check: %s\n", check);
		    exit(EXIT_FAILURE);
	    }

	    goto done;
    }

    if (use_method_count == 0) {
        use_method_serial = true;
    } else if (use_method_count > 1) {
        fail_multiple_method(exec_name);
    }

    if (use_method_serial) {
        sinoscope = sinoscope_create("serial", sinoscope_image_serial, width, height, 200.0);
    } else if (use_method_openmp) {
        sinoscope = sinoscope_create("openmp", sinoscope_image_openmp, width, height, 200.0);
    } else if (use_method_opencl) {
	    sinoscope_opencl_ptr =
		    configure_opencl(opencl_platform_index, opencl_device_index, &sinoscope_opencl, width, height);

        sinoscope = sinoscope_create("opencl", sinoscope_image_opencl, width, height, 200.0);
    } else {
        LOG_ERROR("no method defined");
        exit(1);
    }

    if (sinoscope == NULL) {
        LOG_ERROR("failed to create sinoscope");
        exit(1);
    }

    sinoscope->opencl = sinoscope_opencl_ptr;
    sinoscope->taylor = taylor;

    if (getenv("DISPLAY") == NULL) {
        printf("DISPLAY environment variable not set, forcing headless mode\n");
        do_run_headless = true;
    }

    if (do_save_image) {
        if (sinoscope_save_image(sinoscope, save_filename) < 0) {
            LOG_ERROR("failed to save image");
            exit(1);
        }

        goto done;
    }

    if (do_run_headless) {
        run_headless(sinoscope);
    } else {
        run_viewer(sinoscope);
    }

done:
    if (sinoscope_opencl_ptr != NULL) {
        sinoscope_opencl_cleanup(sinoscope_opencl_ptr);
    }

    if (sinoscope != NULL) {
        sinoscope_destroy(sinoscope);
    }

    return 0;
}
