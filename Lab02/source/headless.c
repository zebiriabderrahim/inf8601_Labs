/* DO NOT EDIT THIS FILE */

#include <errno.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdio.h>
#include <termios.h>
#include <unistd.h>

#include "headless.h"
#include "log.h"

typedef struct timespec timespec_t;
typedef struct termios termios_t;

typedef struct headless {
    sinoscope_t* sinoscope;
    bool exit;

    long fps_count;
    timespec_t fps_start;
} headless_t;

static void* sinoscope_thread_loop(void* data) {
    if (data == NULL) {
        LOG_ERROR_NULL_PTR();
        goto done;
    }

    headless_t* headless = data;
    bool exit            = false;

    while (!exit) {
        if (sinoscope_corners(headless->sinoscope) < 0) {
            LOG_ERROR("failed to forward sinoscope");
        }

        if (headless->sinoscope->handler(headless->sinoscope) < 0) {
            LOG_ERROR("failed to call sinoscope handler `%s`\n\r", headless->sinoscope->name);
        }

        headless->fps_count++;

        __atomic_load(&headless->exit, &exit, __ATOMIC_ACQUIRE);
    }

done:
    return NULL;
}

static void* fps_thread_loop(void* data) {
    if (data == NULL) {
        LOG_ERROR_NULL_PTR();
        goto done;
    }

    headless_t* headless = data;
    timespec_t fps_end;
    bool exit = false;

    while (!exit) {
        if (clock_gettime(CLOCK_MONOTONIC, &fps_end) < 0) {
            LOG_ERROR_ERRNO("clock_gettime");
            goto done;
        }

        float start_sec = headless->fps_start.tv_sec + headless->fps_start.tv_nsec / 1e9;
        float end_sec   = fps_end.tv_sec + fps_end.tv_nsec / 1e9;
        float diff_sec  = end_sec - start_sec;

        printf("FPS: %2.2f\n", (float)headless->fps_count / diff_sec);
        headless->fps_count = 0;
        headless->fps_start = fps_end;

        sleep(1);

        __atomic_load(&headless->exit, &exit, __ATOMIC_ACQUIRE);
    }

done:
    return NULL;
}

static void handle_input_loop(sinoscope_t* sinoscope) {
    termios_t term_old;
    termios_t term_new;

    tcgetattr(STDIN_FILENO, &term_old);
    term_new = term_old;
    term_new.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &term_new);

    bool exit = false;

    while (!exit) {
        int ch = getchar();

        switch (ch) {
        case 'q':
            printf("Closing application\n");
            exit = true;
            break;
        case '1':
            printf("Selected serial implementation\n");
            sinoscope->name    = "serial";
            sinoscope->handler = sinoscope_image_serial;
            break;
        case '2':
            printf("Selected openmp implementation\n");
            sinoscope->name    = "openmp";
            sinoscope->handler = sinoscope_image_openmp;
            break;
        case '3':
            printf("Selected opencl implementation\n");
            sinoscope->name    = "opencl";
            sinoscope->handler = sinoscope_image_opencl;
            break;
        default:
            break;
        }
    }

    tcsetattr(STDIN_FILENO, TCSANOW, &term_old);
}

int headless_run(sinoscope_t* sinoscope) {
    if (sinoscope == NULL) {
        LOG_ERROR_NULL_PTR();
        goto fail_exit;
    }

    headless_t headless = {
        .sinoscope = sinoscope,
        .exit      = false,
        .fps_count = 0,
    };

    if (clock_gettime(CLOCK_MONOTONIC, &headless.fps_start) < 0) {
        LOG_ERROR_ERRNO("clock_gettime");
        goto fail_exit;
    }

    pthread_t sinoscope_thread;
    pthread_t fps_thread;

    errno = pthread_create(&sinoscope_thread, NULL, sinoscope_thread_loop, &headless);
    if (errno != 0) {
        LOG_ERROR_ERRNO("pthread_create");
    }

    errno = pthread_create(&fps_thread, NULL, fps_thread_loop, &headless);
    if (errno != 0) {
        LOG_ERROR_ERRNO("pthread_create");
    }

    handle_input_loop(sinoscope);

    bool value = true;
    __atomic_store(&headless.exit, &value, __ATOMIC_RELEASE);

    errno = pthread_join(sinoscope_thread, NULL);
    if (errno != 0) {
        LOG_ERROR_ERRNO("pthread_join");
    }

    errno = pthread_join(fps_thread, NULL);
    if (errno != 0) {
        LOG_ERROR_ERRNO("pthread_join");
    }

    return 0;

fail_exit:
    return -1;
}
